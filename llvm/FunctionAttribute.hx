package llvm;

enum abstract AllocKind(String) from String to String {
	final Alloc = "alloc";
	final Realloc = "realloc";
	final Free = "free";
	final Uninitialized = "uninitialized";
	final Zeroed = "zeroed";
	final Aligned = "aligned";
}

enum FunctionAttribute {
	AlignStack(n:Int);
	AllocFamily(f:String);
	AllocKind(kind:AllocKind);
	AllocSize(n:Int);
	AlwaysInline;
	Builtin;
	Cold;
	Convergent;
	DisableSanitizerInstrumentation;
	DontCallError;
	DontCallWarn;
	FnRetThunkExtern;
	FramePointer;
	Hot;
	InlineHint;
	JumpTable;
	Memory; // TODO
	MinSize;
	Naked;
	NoInlineLineTables;
	NoJumpTables;
	NoBuiltin;
	NoCallback;
	NoDivergenceSource;
	NoDuplicate;
	NoFree;
	NoImplicitFloat;
	NoInline;
	NoMerge;
	NonLazyBind;
	NoProfile;
	SkipProfile;
	NoRedZone;
	IndirectTLSSegRef;
	NoReturn;
	NoRecurse;
	WillReturn;
	NoSync;
	NoUnwind;
	NoSanitizeBounds;
	NoSanitizeCoverage;
	NullPointerIsValid;
	OptDebug;
	OptForFuzzing;
	OptimizeNone;
	OptimizeForSize;
	PatchableFunction;
	ProbeStack;
	StackProbeSize;
	NoStackArgProbe;
	ReturnsTwice;
	SafeStack;
	SanitizeAddress;
	SanitizeMemory;
	SanitizeThread;
	SanitizeHWAddress;
	SanitizeMemTag;
	SanitizeRealtime;
	SanitizeRealtimeBlocking;
	SpeculativeLoadHardening;
	Speculatable;
	Ssp;
	SspStrong;
	SSPReq;
	StrictFP;
	DenormalFpMath;
	DenormalFpMathF32;
	Thunk;
	UWTable(sync:Bool);
	NoCFCheck;
	ShadowCallStack;
	MustProgress;
	WarnStackSize(threshold:Int);
	VScaleRange(min:Int, ?max:Int);
	NoOutline;
}

class FunctionAttributeUtil {
	public static function toString(attr:FunctionAttribute) : String {
		switch attr {
			case AlignStack(n): return 'alignstack(${n})';
			case AllocFamily(f): return 'allocfamily(${f})';
			case AllocKind(kind): return 'allockind(${kind})';
			case AllocSize(n): return 'allocsize(${n})';
			case AlwaysInline: return 'alwaysinline';
			case Builtin: return 'builtin';
			case Cold: return 'cold';
			case Convergent: return 'convergent';
			case DisableSanitizerInstrumentation: return 'disablesanitizerinstrumentation';
			case DontCallError: return 'dontcallerror';
			case DontCallWarn: return 'dontcallwarn';
			case FnRetThunkExtern: return 'fnretthunkextern';
			case FramePointer: return 'framepointer';
			case Hot: return 'hot';
			case InlineHint: return 'inlinehint';
			case JumpTable: return 'jumptable';
			case Memory: return 'memory';
			case MinSize: return 'minsize';
			case Naked: return 'naked';
			case NoInlineLineTables: return 'noinlinelinetables';
			case NoJumpTables: return 'nojumptables';
			case NoBuiltin: return 'nobuiltin';
			case NoCallback: return 'nocallback';
			case NoDivergenceSource: return 'nodivergencesource';
			case NoDuplicate: return 'noduplicate';
			case NoFree: return 'nofree';
			case NoImplicitFloat: return 'noimplicitfloat';
			case NoInline: return 'noinline';
			case NoMerge: return 'nomerge';
			case NonLazyBind: return 'nonlazybind';
			case NoProfile: return 'noprofile';
			case SkipProfile: return 'skipprofile';
			case NoRedZone: return 'noredzone';
			case IndirectTLSSegRef: return 'indirecttlssegref';
			case NoReturn: return 'noreturn';
			case NoRecurse: return 'norecurse';
			case WillReturn: return 'willreturn';
			case NoSync: return 'nosync';
			case NoUnwind: return 'nounwind';
			case NoSanitizeBounds: return 'nosanitizebounds';
			case NoSanitizeCoverage: return 'nosanitizecoverage';
			case NullPointerIsValid: return 'nullpointerisvalid';
			case OptDebug: return 'optdebug';
			case DenormalFpMath: return 'denormalfpmath';
			case DenormalFpMathF32: return 'denormalfpmathf32';
			case MustProgress: return 'mustprogress';
			case NoCFCheck: return 'nocfcheck';
			case NoOutline: return 'nooutline';
			case NoStackArgProbe: return 'nostackargprobe';
			case OptForFuzzing: return 'optforfuzzing';
			case OptimizeForSize: return 'optimizeforsize';
			case OptimizeNone: return 'optimizenone';
			case PatchableFunction: return 'patchablefunction';
			case ProbeStack: return 'probestack';
			case ReturnsTwice: return 'returnstwice';
			case SSPReq: return 'sspreq';
			case SafeStack: return 'safestack';
			case SanitizeAddress: return 'sanitizeaddress';
			case SanitizeHWAddress: return 'sanitizehwaddress';
			case SanitizeMemTag: return 'sanitizememtag';
			case SanitizeMemory: return 'sanitizememory';
			case SanitizeRealtime: return 'sanitizerealtime';
			case SanitizeRealtimeBlocking: return 'sanitizerealtimeblocking';
			case SanitizeThread: return 'sanitizethread';
			case ShadowCallStack: return 'shadowcallstack';
			case Speculatable: return 'speculatable';
			case SpeculativeLoadHardening: return 'speculativeloadhardening';
			case Ssp: return 'ssp';
			case SspStrong: return 'sspstrong';
			case StackProbeSize: return 'stackprobesize';
			case StrictFP: return 'strictfp';
			case Thunk: return 'thunk';
			case UWTable(sync): return 'uwtable(${sync})';
			case VScaleRange(min, max): return 'vscalerange(${min}, ${max})';
			case WarnStackSize(threshold): return 'warnstacksize(${threshold})';
		}
	}
}